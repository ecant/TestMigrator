import SwiftSyntax

struct ParsedQuickClass {
    let className: String
    let otherItems: CodeBlockItemListSyntax?
    let beforeEachBlocks: [CodeBlockItemListSyntax]
    let afterEachBlocks: [CodeBlockItemListSyntax]
    let tests: [ParsedQuickTest]
}

struct ParsedQuickTest {
    let descriptions: [String]
    private let itBlock: CodeBlockItemListSyntax
    private let describeBlocks: [ParsedQuickDescribeBlock]
    
    var blocks: [CodeBlockItemListSyntax] {
        let otherItems = describeBlocks.reversed().map { $0.otherItems }
        
        /// The blocks were generated by first finding an "it" block and then traversing each parent node until reaching the top of the spec.
        /// So here we want to reverse the beforeEach blocks so they're in the order they should be executed in a text.
        let beforeEachBlocks = describeBlocks.reversed().flatMap { $0.beforeEachBlocks }
        
        /// The closest after each blocks to the "it" block should be run first, so these are in the correct order already
        let afterEachBlocks = describeBlocks.flatMap { $0.afterEachBlocks }

        return otherItems + beforeEachBlocks + [itBlock] + afterEachBlocks
    }
    
    fileprivate init(itBlock: CodeBlockItemListSyntax, descriptions: [String], describeBlocks: [ParsedQuickDescribeBlock]) {
        self.itBlock = itBlock
        self.descriptions = descriptions
        self.describeBlocks = describeBlocks
    }
    
    fileprivate func appending(description: String, describeBlock: ParsedQuickDescribeBlock) -> Self {
        ParsedQuickTest(
            itBlock: self.itBlock,
            descriptions: self.descriptions + [description],
            describeBlocks: self.describeBlocks + [describeBlock]
        )
    }
}

struct ParsedQuickDescribeBlock {
    let beforeEachBlocks: [CodeBlockItemListSyntax]
    let afterEachBlocks: [CodeBlockItemListSyntax]
    let otherItems: CodeBlockItemListSyntax
}

enum QuickClassParser {
    static func parseClass(from classDecl: ClassDeclSyntax) -> ParsedQuickClass {
        let className = classDecl.name.text

        guard let specFunction = classDecl.specFunctionContents else {
            return ParsedQuickClass(className: className,
                                    otherItems: nil,
                                    beforeEachBlocks: [],
                                    afterEachBlocks: [],
                                    tests: [])
        }
        
        let testVisitor = TestVisitor(viewMode: .sourceAccurate)
        testVisitor.walk(specFunction)
        
        return ParsedQuickClass(className: className,
                                otherItems: specFunction.otherItems,
                                beforeEachBlocks: specFunction.beforeEachBlocks,
                                afterEachBlocks: specFunction.afterEachBlocks,
                                tests: testVisitor.parsedTests)
    }
    
    private final class TestVisitor: SyntaxVisitor {
        var parsedTests: [ParsedQuickTest] = []
        
        override func visit(_ node: FunctionCallExprSyntax) -> SyntaxVisitorContinueKind {
            guard node.isItBlock else { return .visitChildren }
            
            guard let description = node.blockDescription, let itBlockContents = node.trailingClosure?.statements else {
                return .skipChildren
            }
            
            let initialTest = ParsedQuickTest(itBlock: itBlockContents,
                                       descriptions: [description],
                                       describeBlocks: [])
            
            let result = Self.parseTestAndAncestors(node: node, result: initialTest)
            parsedTests.append(result)
            
            return .skipChildren
        }
        
        /// Recursive function. Traverses the syntax tree starting from the test (i.e. "it" block), finding all the ancestor nodes until the top of the spec is reached.
        private static func parseTestAndAncestors(node: SyntaxProtocol, result: ParsedQuickTest) -> ParsedQuickTest {
            guard let parent = node.parent else {
                return result
            }
            
            /// If this node is not a relevant block, continue to next ancestor.
            guard let parentAsFunctionCall = parent.as(FunctionCallExprSyntax.self), parentAsFunctionCall.isDescribeOrContextBlock else {
                return parseTestAndAncestors(node: parent, result: result)
            }
            
            let statements = parentAsFunctionCall.trailingClosure?.statements ?? []

            let newResult = result.appending(description: parentAsFunctionCall.blockDescription!,
                                             describeBlock: Self.parseDescribeBlock(statements: statements))
            
            return parseTestAndAncestors(node: parent, result: newResult)
        }
        
        private static func parseDescribeBlock(statements: CodeBlockItemListSyntax) -> ParsedQuickDescribeBlock {
            let beforeEachBlocks = statements
                .compactMap { codeBlockItem -> CodeBlockItemListSyntax? in
                    guard let funcExpr = codeBlockItem.item.as(FunctionCallExprSyntax.self) else { return nil }
                    return funcExpr.isBeforeEachBlock ? funcExpr.trailingClosure?.statements : nil
                }
            
            let afterEachBlocks = statements
                .compactMap { codeBlockItem -> CodeBlockItemListSyntax? in
                    guard let funcExpr = codeBlockItem.item.as(FunctionCallExprSyntax.self) else { return nil }
                    return funcExpr.isAfterEachBlock ? funcExpr.trailingClosure?.statements : nil
                }
            
            let otherItems = statements
                .filter { codeBlockItem in
                    guard let funcExpr = codeBlockItem.item.as(FunctionCallExprSyntax.self) else { return true }
                    if funcExpr.isBeforeEachBlock ||
                        funcExpr.isAfterEachBlock ||
                        funcExpr.isItBlock ||
                        funcExpr.isDescribeOrContextBlock {
                        return false
                    }
                    return true
                }
            
            return ParsedQuickDescribeBlock(beforeEachBlocks: beforeEachBlocks,
                                            afterEachBlocks: afterEachBlocks,
                                            otherItems: CodeBlockItemListSyntax(otherItems))
        }
    }
}
